package transform;

import java.util.ArrayList;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import agent.InstanceIdentifier;
import agent.Settings;

/**
 * A {@link ClassVisitor} for instrumenting client programs that allows the
 * agent to collect various data during execution of these programs for the
 * purpose of dynamic analysis.
 *
 * @author Nikolay Pulev <N.Pulev@sms.ed.ac.uk>
 */
public class DataCollector extends ClassVisitor {

    private int access;
    private boolean hasIdField = false;
    private String className;

    public DataCollector(ClassVisitor cv) {
        super(Opcodes.ASM4, cv);
    }

    @Override
    public void visit(int version, int access, String name, String signature, String superName,
            String[] interfaces) {

        /*
         * Change version of loaded java class to 1.5 if less than 1.4. Needed
         * because the loading of class constants in the constant pool (as
         * "mv.visitLdcInsn(currentElem.type)" does in
         * InstanceCreationVisitor::visitMethodInsn()) is not supported by some
         * older Java versions. Because the version of the classes being
         * instrumented is unknown, this may sometimes cause validation errors.
         *
         * Cause of validation error suggested by:
         * http://mail-archive.ow2.org/asm/2009-06/msg00011.html
         *
         * Example outputs (with and without the validation error) of the
         * command "mvn -e test &> <output*>", the generated bytecode and a diff
         * file are available in ${basedir}/doc/class-constants-issue directory.
         *
         * TODO: Could this case additional problems?
         */
        ArrayList<Integer> javaVersions = new ArrayList<Integer>();
        javaVersions.add(Integer.valueOf(Opcodes.V1_1));
        javaVersions.add(Integer.valueOf(Opcodes.V1_2));
        javaVersions.add(Integer.valueOf(Opcodes.V1_3));
        javaVersions.add(Integer.valueOf(Opcodes.V1_4));
        this.access = access;
        this.className = name;
        cv.visit((javaVersions.contains(version)) ? Opcodes.V1_5 : version, access, name,
                signature, superName, interfaces);
    }

    @Override
    public MethodVisitor visitMethod(int access, String name, String desc, String signature,
            String[] exceptions) {
        MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);

        if (mv == null) {
            return mv;
        }

        /*
         * Transform to collect data about object creations & accesses.
         * InstanceAccessVisitor is first in the chain to prevent it from
         * instrumenting accesses generated by InstanceCreationVisitor.
         *
         * CHAIN:
         *      InstanceAccessVisitor -> InstructionOffsetVisitor ->
         *          InstanceCreationVisitor (instruments last)
         */
        if (Settings.INSTANCE.get(Settings.SETT_INST_CREAT).equals("true")) {
            InstanceCreationVisitor icv = new InstanceCreationVisitor(mv, name);
            mv = new InstructionOffsetVisitor(icv); /* icv depends on this insn ofst provider. */
        }
        return new InstanceAccessVisitor(mv, name, className);
    }

    public FieldVisitor visitField(int access, String name, String desc, String signature,
            Object value) {
        if (name.equals(InstanceIdentifier.ID_NAME)) {
            hasIdField = true;
        }

        return cv.visitField(access, name, desc, signature, value);
    }

    @Override
    public void visitEnd() {

        /* Add ID field if not present and class is not abstract. */
        if (!hasIdField && (access & Opcodes.ACC_ABSTRACT) == 0
                && (Settings.INSTANCE.get(Settings.SETT_FLD_ACCS).equals("true")
                        || Settings.INSTANCE.get(Settings.SETT_MTD_ACCS).equals("true"))) {
            cv.visitField(Opcodes.ACC_PRIVATE + Opcodes.ACC_VOLATILE, InstanceIdentifier.ID_NAME,
                    Type.LONG_TYPE.getDescriptor(), null, null);
        }
        cv.visitEnd();
    }
}
